<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>MyWireguard</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<p>Remote, Remote,Remote !</p>
<p>I need to be able to access my lab from outside my local network.</p>
<p>I’m essentially working on a laptop and have a small home lab on a
desktop machine.</p>
<p>I wanted also to be able to access my “smart home” system remotely
when I’m out for long time.</p>
<p>For that purpose, I have setup remote access using Wireguard. And the
good thing is that my home router has the capability to do set up a
Wireguard server.</p>
<p>Here is the journey of setting up this remote access to my local
network.</p>
<p>First configure Wireguard on my router</p>
<p>1 – Configure Wireguard on my router</p>
<p>Thanks to the design of Wireguard the setup was quite easy on my
router.</p>
<p>I had essentially to enable the Wireguard VPN in the UI.</p>
<p><img src="./Pictures/10000000000003D7000004347F63B3817C9E1804.png"
style="width:6.9252in;height:7.5799in" /></p>
<p>Then click on the + button to add ad a VPN client, the Peer popup
shows and I just have to click on the apply button.</p>
<p><img src="./Pictures/10000000000001EF0000013DC08649979E31CF07.png"
style="width:5.1555in;height:3.3016in" /></p>
<p>After that on my phone after downloading the wigurad client app,</p>
<p>I can scan the QR code to add the connection.</p>
<p><img src="./Pictures/10000000000001DE0000034BABCF1FABCBEA5A36.png"
style="width:3.5646in;height:6.2862in" /></p>
<p>Or export the configuration file to use import it either on my phone
Wireguard client or in a Wireguard client on my laptop.</p>
<p><img src="./Pictures/10000000000001D7000002EFF986ACAE42505009.png"
style="width:3.8409in;height:6.1244in" /></p>
<p>2 – Configure DNS update on my rpi</p>
<p>Because I’m using a home internet connection, my public IP address is
rotating regularly.</p>
<p>To avoid having to reconfigure my vpn client every time my IP has
changed, I have resurected and rewritten in rust on old tool I have been
using to update a DNS hostname with the latest Public IP.</p>
<p>&gt;&gt; dnsupdate rust tool.</p>
<p>Essentially this small tool is reaching retreiving my public IP
address</p>
<p>Updating my a dns fqdn to my dnsprovider</p>
<p>Then I use this dns hostname as my target for my Wireguard.</p>
<p>As usual the tool is available on github :
https://github.com/Vagrantin/dnsupdate</p>
<p>Configure the RPI to run the tool</p>
<p>First I had to cross-compile my tool for Raspberry as it is running
on ARM.</p>
<p>1. Install the Rust ARM Target</p>
<p>Add the ARM target for Rust:</p>
<p>rustup target add arm-unknown-linux-gnueabihf</p>
<p>2. Install the ARM Toolchain</p>
<p>Install the GNU ARM toolchain for cross-compilation:</p>
<p>sudo apt update</p>
<p>sudo apt install gcc-arm-linux-gnueabihf</p>
<p>3. Configure Cargo for Cross-Compilation</p>
<p>Create or edit `~/.cargo/config.toml` to specify the linker for the
ARM target:</p>
<p>```</p>
<p>[target.arm-unknown-linux-gnueabihf]</p>
<p>linker = "arm-linux-gnueabihf-gcc"</p>
<p>```</p>
<p>4. Cross-Compile Your Program</p>
<p>Run the following command to build your program for ARM:</p>
<p>```</p>
<p>cargo build --release --target=arm-unknown-linux-gnueabihf</p>
<p>```</p>
<p>5. Locate the Compiled Binary</p>
<p>The compiled binary will be in:</p>
<p>```</p>
<p>target/arm-unknown-linux-gnueabihf/release/your_program_name</p>
<p>```</p>
<p>6. Copy the Binary to Your Raspberry Pi</p>
<p>Use `scp` to transfer the binary to your Raspberry Pi:</p>
<p>```</p>
<p>scp target/arm-unknown-linux-gnueabihf/release/your_program_name
pi@your_raspberry_pi_ip:/home/pi/</p>
<p>```</p>
<p>7. Copy the Binary to Your Raspberry Pi</p>
<p>Then I copied the binary and the configuration file in the
“/opt/pibox” folder </p>
<p>I then update the configuration file with my API key, dns provider
endpoint and the hostname that I want to keep up to date</p>
<p>8. Finally I create a Systemd timer to run this small tool every
10mins</p>
<p>Fill in the file “/etc/systemd/system/dnsupdate.timer” with this
content, it will wait 5mins after boot to trigger the first update and
then run the program every 10mins</p>
<p>```</p>
<p>[Unit]</p>
<p>Description= Trigger dnsupdate every 10 minutes</p>
<p>[Timer]</p>
<p>OnBootSec=5min</p>
<p>OnUnitActiveSec=10min</p>
<p>Persistent=true</p>
<p>[Install]</p>
<p>WantedBy=timers.target</p>
<p>```</p>
<p>You also need to create the related service for Systemd,</p>
<p>Fill in the file “/etc/systemd/system/dnsupdate.service</p>
<p>```</p>
<p>[Unit]</p>
<p>Description=Update public ip address to my fqdn</p>
<p>[Service]</p>
<p>Type=oneshot</p>
<p>ExecStart=/opt/pibox/dnsupdate /opt/pibox/myconfig.toml</p>
<p>```</p>
<p>You then have to reload systemd to load this new service and related
timer and then restart the timer related to the tool.</p>
<p>```</p>
<p>sudo systemctl daemon-reload</p>
<p>sudo systemctl restart myapp.timer</p>
<p>```</p>
<p>You can then check what is the status of your timer with this
command, and you can seen when was the last time it has been
triggered</p>
<p>```</p>
<p>systemctl list-timers | grep dnsupdate</p>
<p>Wed 2026-02-04 19:04:19 JST 4min 7s […] 5min ago dnsupdate.timer
dnsupdate.service</p>
<p>```</p>
<p>Sytemctl dnsupdate.service and triggered by dnsupdate.timer</p>
<p>And you are done, you can now access your LAN from outside and
continue to tinker even if you’re not at home ! Unlimited DIY !</p>
<p>Hope you enjoyed it, see you next time !</p>
</body>
</html>
