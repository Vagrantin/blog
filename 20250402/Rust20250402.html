<h1 id="the-reality-of-vibe-coding-a-rust-non-developers-journey">The
Reality of "Vibe Coding": A Rust non-Developer's journey</h1>
<h2 id="introduction-to-the-phenomenon">Introduction to the
Phenomenon</h2>
<p>In February 2025, ex-OpenAI co-founder Andrej Karpathy coined the
term "vibe coding" - a seemingly utopian approach where developers
"fully give in to the vibes, embrace exponentials, and forget that the
code even exists." This methodology has sparked controversy in developer
circles, being criticized as "programming without programming
knowledge." As a Rust enthusiast, I decided to put this approach to the
test.</p>
<h2 id="the-promise-vs.-the-reality">The Promise vs. The Reality</h2>
<h3 id="the-promise">The Promise:</h3>
<p><em>claude.ai → Magic → Working Tool → Productivity Nirvana</em></p>
<h3 id="the-reality">The Reality:</h3>
<p><em>fn actual_vibe_coding() -&gt; Result&lt;Tool, VibingError&gt;
{</em></p>
<p><em> loop {</em></p>
<p><em> let prompt = craft_extremely_precise_prompt()?;</em></p>
<p><em> let generated_code = claude_ai.generate(prompt)?;</em></p>
<p><em> </em></p>
<p><em> // Required step that vibe coding evangelists never
mention</em></p>
<p><em> if !human_actually_reads_code(&amp;generated_code) {</em></p>
<p><em> return Err(VibingError::UnreviewedCodeDisaster);</em></p>
<p><em> }</em></p>
<p><em> </em></p>
<p><em> match fix_inevitable_mistakes(&amp;generated_code) {</em></p>
<p><em> Ok(fixed_code) =&gt; {</em></p>
<p><em> if test_on_sample_data(&amp;fixed_code).is_ok() {</em></p>
<p><em> return Ok(fixed_code);</em></p>
<p><em> }</em></p>
<p><em> },</em></p>
<p><em> Err(_) =&gt; continue, // Back to square one</em></p>
<p><em> }</em></p>
<p><em> }</em></p>
<p><em>}</em></p>
<h2 id="the-8-step-vibe-coding-protocol">The 8-Step "Vibe Coding"
Protocol</h2>
<ol type="1">
<li><strong>Prompt Engineering</strong>: Craft a request with the
precision of a neurosurgeon (I recommend using Rust – see in step
4).</li>
<li><strong>Code Review</strong>: Actually read the generated code. Yes,
shocking, I know.</li>
<li><strong>Enter Panic Mode</strong>: Yes, you will be shocked, the
'AI' has written spaghetti code.</li>
<li><strong>Error Correction</strong>: Fix all stupid mistake, as the AI
tool doesn’t have any understanding what it through at you, this is
where Rust is very nice becaues Rust compiler will help you a lot in
memory related issues, for the rest you are on your own :D.</li>
<li><strong>Testing</strong>: Apply the shocking concept of validating
functionality on sample data.</li>
<li><strong>Troubleshooting</strong>: When (not if) it fails, return to
step 1 with increasingly precise prompts if you can’t/don’t want to fix
it yourself. This should be done at the very precise point where you
have identified the issue.</li>
<li><strong>Perseverance</strong>: Loop from step 1 to 6 until you are
happy with the result.</li>
<li><strong>Production Caution</strong>: Never deploy to production
unless you understand every line of code - a principle that apparently
needs stating in the age of "vibe coding."</li>
</ol>
<h2 id="my-personal-use-case">My Personal Use Case</h2>
<p>I've limited my "vibe coding" adventures to creating small utility
tools that enhance my daily workflow. This approach works for me
because:</p>
<ol type="1">
<li>I practice what I call "Vibe QA" - a methodology built on having
crystal-clear requirements </li>
<li>My tools are small enough to be reviewed before implementation </li>
<li>I maintain a healthy skepticism about the generated code's quality
</li>
</ol>
<h2 id="tools-created-this-month">Tools Created This Month</h2>
<p><a
href="https://github.com/Vagrantin/findinfiles"><em>https://github.com/Vagrantin/findinfiles</em></a></p>
<p><em></em></p>
<p><em>A Rust utility that searches files for specific terms and
automatically copies matching files to a designated directory.</em></p>
<p><em></em></p>
<p><a
href="https://github.com/Vagrantin/grabpdf"><em>https://github.com/Vagrantin/grabpdf</em></a><em><br />
<br />
A Rust tool to download all PDFs from a website url.</em></p>
<p><em></em></p>
<p><a
href="https://github.com/Vagrantin/file_merger_tool"><em>https://github.com/Vagrantin/file_merger_tool</em></a></p>
<p><em></em></p>
<p><em>A Rust-based command-line tool for merging or processing two
input files and saving the output</em></p>
<p><em></em></p>
<p><a
href="https://github.com/Vagrantin/stripehtmltags"><em>https://github.com/Vagrantin/stripehtmltags</em></a></p>
<p><em></em></p>
<p><em>A Rust-based command-line utility that strips HTML tags from
files, outputting only the clean text content with one item per
line.</em></p>
<p><em></em></p>
<p><a
href="https://github.com/Vagrantin/recursefilecreator"><em>https://github.com/Vagrantin/recursefilecreator</em></a></p>
<p><em><br />
A Rust tool that recursively creates files in all directories within a
given path.</em></p>
<p><em></em></p>
<p><a
href="https://github.com/Vagrantin/buildstatus"><em>https://github.com/Vagrantin/buildstatus</em></a></p>
<p><em></em></p>
<p><em>A Rust CLI tool that parses XML files from a directory and
exports structured data to a CSV file.</em></p>
<p><em></em></p>
<h2 id="conclusion">Conclusion</h2>
<p>While "vibe coding" might not revolutionize software development as
its proponents suggest, it can serve as a productivity multiplier for
small, well-defined tasks when combined with proper review processes and
a solid understanding of programming fundamentals. Just remember - the
"vibe" in "vibe coding" should stand for "Verify, Inspect, Bug-hunt, and
Evaluate."</p>
<p>PS: Article re-written by claude.ai from my original though, then I
fixed it to look the way I wanted.</p>
<p><em></em></p>
<p><em></em></p>
<p><em></em></p>
<p><em></em></p>
<p><em></em></p>
